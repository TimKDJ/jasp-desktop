## Part I: Definition and Goals

### Definition
Syntax mode refers to the ability for users to see what code generates the output they see. This includes filters, computed columns and analyses.

### Use Case
1. Syntax mode will provide a smoother transition from SPSS that makes heavy use of syntax.
2. With syntax mode it becomes easier to develop new R analyses as they can be run from RStudio with little effort.
3. Syntax can easily be shared between colleagues and attached to appendices.
4. JASP can be a tool to expose students to R.

### Primary Goals of Syntax Mode
1. The syntax will cover filters, computed columns and analyses.
2. The syntax will be valid R and can be run outside of JASP.
3. The syntax will be consistent with the syntax you would provide to regular R packages (e.g., `stats::lm()`).
4. The user will need to perform minimal additional steps after copy-pasting to generate output similar of that seen in JASP (i.e., only read data).
5. The output of the syntax in RStudio will generate a structure that R users are familiar with.
6. The syntax is set up in a way that will, **in the future**, allow users to execute syntax inside of JASP and have JASP perform the specified filters/computed columns/analyses.

### Intended Limitations of Syntax Mode
1. The syntax does not need to be executable in JASP at present, but we'll likely want that at a later stage.
2. The syntax can be separate statements that are not linked together. What this means is that it is acceptable not to include package installing, data reading and temporary variables (although we could add this as an additional feature). By doing this we will ensure it will be easier to later execute our generated syntax inside of JASP (once we reach that point).
   
Separate statements:
```
filter(...)
mutate(...)
anova(...)
```
Linked statements:
```
if (!require(jasp)) install.packages("jasp")
library(jasp)
read.csv(...) %>% filter(...)
              %>% mutate(...)
              %>% anova(...)
```

## Part II: Examples of Intended Syntax

### Filters
Based on `dplyr::filter()`, with only a small adjustment to their logic: allow no data to be passed in, in which case we search for a dataset in the `parent.frame`. This ensures we don't have to enter `dplyr::filter(data = dataset, ...)` everywhere. The following filter types are already supported by `dplyr::filter()` and return filtered `data.frame`s:
```
# filter from "drag 'n drop interface"
filter(contNormal < 0)


# filter from "R interface"
filter({
    temp1 <- facExperim
    temp1 == 1 & contBinom == 0
})
```

### Computed Columns
Based on `dplyr::mutate()`, with the same proposed change of removing `data` (and a rename of the function to `compute`). The following ways of column adding are already supported by `dplyr::mutate()` and return `data.frame`s with the additional columns:
```
# single new column titled 'sumScore' created from "drag 'n drop interface"
compute(sumScore = contNormal + contGamma)


# two new columns titled 'logContNormal' and 'expContGamma' (we don't support this in JASP)
compute(logContNormal = log(contNormal), expContGamma = contGamma^2)


# single new column titled 'sumScore' created from "R interface"
compute(logSumScore = {
  sumScore <- contNormal + contGamma
  log(sumScore)
})
```

### Analyses
These functions are intended to be alike to statistical functions such as `stats::lm()`, especially in regards to the use of formula's. JASP analysis functions should only deviate from other R functions when it comes to output. Whereas JASP will creates lots of output from a single function call, regular R functions generally only do "one thing". However, our approach might actually be beneficial as it requires the users to only know about one single function. To accomplish a clean interface for the analyses, we will need wrappers around the existing analyses. This is an example call to a wrapper around our ANOVA analysis:
```
# calling an anova with a formula
anova(formula = contNormal ~ facGender + facExperim + facGender * facExperim,
      descriptives = TRUE)
```

##### Formula's
Formula's complicate the implementation, but simplify the syntax. Furthermore, they are the standard way in which models are specified in R packages. The next example shows the benefit of formula's by repeating the ANOVA call, but without using a formula:
```
# calling an anova without a formula
anova(dep = "contNormal",
      fixed = c("facGender", "facExperim"),
      modelTerms = list(list(components = "facGender"), list(components = "facExperim"), list(components = c("facGender", "facExperim"))),
      descriptives = TRUE)
```


## Part III: Implementation Details

### Flow chart

![image info](flow-chart-syntax-mode(2).png)

### Generating a Wrapper Around an Analysis
The wrapper can be automatically generated by an R script. However, this R script requires a summary of analysis.qml and description.qml. Considering writing a good QML parser has kindly been performed for us by Qt it makes sense we use the JASP executable for this. Ideally this function will be callable from R so users can develop their entire analysis in RStudio.

<details>

<summary>Example summary of three components</summary>

description.qml:
```
...
	"menu":
	[
		{
			"title":    "ANOVA",
			"function":	"anova"
		}
    ]
```

analysis.qml:
```
Form 
{
    info: "Allows the user to analyze the difference between multiple group means."

    AssignedVariablesList 
    { 
        name: "fixedFactors"
        title: qsTr("Fixed Factors")
        allowedColumns: ["ordinal", "nominal"]
        info: "The variables that are manipulated/define the different groups."
    }

    CheckBox 
    { 
        name: "descriptives";	
        label: qsTr("Descriptive statistics")
        info: "Descriptives for each combination of levels of the independent variables."
        childrenOnSameRow: true
        CIField { name: "ci"; info: "% confidence interval" }	
    }
}
```
Generated summary:
```
{
    "function": "anova",
    "info": "Allows the user to analyze the difference between multiple group means.",

    "options": 
    [
        {
            "name": "fixedFactors",
            "type": "variables",
            "allowed": ["ordinal", "nominal"],
            "default": "",
            "info": "The variables that are manipulated/define the different groups."
        },

        {
            "name": "descriptives",
            "type": "bool",
            "default": false,
            "info": "Descriptives for each combination of levels of the independent variables."
        },

        {
            "name": "ci",
            "type": "double",
            "min": 0,
            "max": 100,
            "default": 95,
            "info": "% confidence interval"
        }
    ]
}
```

Header of anova_wrapper.R:
```
#' Allows the user to analyze the difference between multiple group means.
#'
#' @param fixedFactors The variables that are manipulated/define the different groups.
#' @param descriptives Descriptives for each combination of levels of the independent variables.
#' @param ci % confidence interval.
anova <- function(fixedFactors = "", descriptives = FALSE, ci = 95) {
    ...
}
```

</details>

#### Specifying a Formula

### The Wrapper
The wrapper should deal with the setup and breakdown of jaspResults, as well as the validation of provided options.
-    Thin wrapper around analysis that creates the options list and initializes jaspResults
-    Needs to be possible to generate a json representation of the options
    -    Formulaâ€™s
    -    Validation
-    Need a R6 options class (min, max, allowedColumns)
    -    Be able to be called from R so developers can create a wrapper during module creation

- Wrapper needs to call the Options Class to validate input
- Wrapper needs to piece together the formula
- Wrapper initializes jaspResults
- Wrapper calls analysis
- Wrapper breaks down jaspResults (if necessary)

<details>

<summary>Example wrapper that shows how the formula's can be used</summary>

```
bancova <- function(formula           = NULL,
                    data              = NULL,
                    dep               = "",
                    fixed             = list(),
                    random            = list(),
                    covariates        = list(),
                    model             = list(),
                    nullModel         = NULL,
                    priorFixed        = 0.5,
                    priorRandom       = 1,
                    priorCovariates   = 0.354,
                    effects           = FALSE,
                    effectsType       = "allModels",
                    postEst           = FALSE,
                    ci                = 0.95,
                    criTable          = FALSE,
                    bfOrder           = "bestModelTop",
                    bfType            = "BF10",
                    groupPost         = "grouped",
                    singleModel       = list(),
                    singleEst         = FALSE,
                    singleCriTable    = FALSE,
                    singlePostPlot    = FALSE,
                    singleQqPlot      = FALSE,
                    singleRsqPlot     = FALSE,
                    singleGroupPost   = "grouped",
                    postHocVars       = list(),
                    postHocNull       = TRUE,
                    descr             = FALSE,
                    descrVarOnYAxis   = "",
                    descrVarAsLines   = "",
                    descrVarAsPlots   = "",
                    wantPlotCi        = FALSE,
                    plotCi            = 0.95,
                    postPlot          = FALSE,
                    qqPlot            = FALSE,
                    rsqPlot           = FALSE,
                    fixedNumAcc       = 1,
                    fixedMCMCSamples  = 1,
                    sampleModeNumAcc  = "auto",
                    sampleModeMCMC    = "auto") {
  
  defaultArgCalls <- formals(as.character(match.call()[[1]]))
  defaultArgs <- lapply(defaultArgCalls, eval)
  
  options <- as.list(match.call())
  options <- modifyList(options, defaultArgs)
  options[[1]] <- NULL
  options[["data"]] <- NULL
  
  if (!is.null(formula)) {
    
    if (!inherits(formula, "formula"))
      formula <- as.formula(formula)
    
    if (dep != "")
      formula <- addToFormula(formula, terms = dep, type = "lhs")
    if (length(fixed) > 0)
      formula <- addToFormula(formula, terms = fixed, type = "rhs")
    if (length(random) > 0)
      formula <- addToFormula(formula, terms = random, type = "rhs")
    if (length(covariates) > 0)
      formula <- addToFormula(formula, terms = covariates, type = "rhs")
    
    options$dep <- getFromFormula(formula, data, type = "lhs", mode = "numeric", exclude = random, nullValue = defaultArgs[["dep"]])
    options$fixed <- getFromFormula(formula, data, type = "rhs", mode = "factor", exclude = random, nullValue = defaultArgs[["fixed"]])
    options$covariates <- getFromFormula(formula, data, type = "rhs", mode = "numeric", exclude = random, nullValue = defaultArgs[["covariates"]])
    
    if (length(model) == 0)
      options$model <- createModelFromFormula(formula, type = "rhs", nuisance = list(name = "isNuisance", terms = nullModel))
    
    if (length(singleModel) == 0)
      options$singleModel <- createModelFromFormula(formula, type = "rhs")
  }
  
  # this will go as name changes are permanent
  options <- convertOptionNames(options)
  jasptools::run("AncovaBayesian", dataset=data, options=options)
  
  #jaspResults <- initJaspResults()
  #JASP:::AncovaBayesian(jaspResults=jaspResults, dataset=data, options=options)
  #summary(jaspResults)
  #return(invisible(jaspResults$asResults()))
}

createModelFromFormula <- function(formula, type, nuisance = list(), excludeInteractions = FALSE) {
  if (! type %in% c("lhs", "rhs"))
    stop("Can only get rhs or lhs terms from a formula")
  
  components <- splitFormula(formula, excludeInteractions)[[type]]
  
  model <- vector("list", length(components))
  for (i in seq_along(components)) {
    model[[i]] <- createModelComponentItem(components[[i]], nuisance)
  }
  
  return(model)
}

createModelComponentItem <- function(component, nuisance) { # nuisance needs to be expanded to other column types..
  result <- list()
  result[["components"]] <- expandInteractionTerm(component)
  if (length(nuisance) > 0) {
    
    nuisanceTerms <- NULL
    if (inherits(nuisance[["terms"]], "formula"))
      nuisanceTerms <- splitFormula(nuisance[["terms"]])[["rhs"]]
    
    result[[nuisance[["name"]]]] <- isTRUE(component %in% nuisanceTerms)
  }
  
  return(result)
}

expandInteractionTerm <- function(term) {
  return(unlist(strsplit(term, ":", fixed = TRUE)))
}

getFromFormula <- function(formula, data, type, mode = NULL, exclude = c(), nullValue = NULL) {
  if (! type %in% c("lhs", "rhs"))
    stop("Can only get rhs or lhs terms from a formula")
  
  if (!is.data.frame(data))
    stop("Expecting data to be a data.frame")
  
  components <- splitFormula(formula, excludeInteractions = TRUE)[[type]]
  components <- getComponentsOfCorrectMode(components, data, mode)
  components <- setdiff(components, exclude)
  
  if (length(components) == 0)
    components <- nullValue
  
  return(components)
}

getComponentsOfCorrectMode <- function(components, data, mode) {
  if (!all(components %in% names(data)))
    stop("Not all formula components appear in the dataset")
  
  result <- NULL
  for (component in components) {
    if (mode == "factor" && is.factor(data[[component]]))
      result <- c(result, component)
    else if (mode == "numeric" && is.numeric(data[[component]]))
      result <- c(result, component)
  }
  
  return(result)
}

splitFormula <- function(formula, excludeInteractions = FALSE) {
  if (!inherits(formula, "formula"))
    stop("Expecting formula to be of class `formula`")
  
  terms <- as.character(formula)
  if (length(terms) < 3) { # there is no lhs
    lhs <- NULL
    rhs <- terms[2]
  } else {
    lhs <- terms[2]
    rhs <- terms[3]
  }
  
  return(list(lhs = getComponentsFromTerm(lhs, excludeInteractions),
              rhs = getComponentsFromTerm(rhs, excludeInteractions)))
}

addToFormula <- function(formula, terms, type) {
  ### what about interactions?
  if (! type %in% c("lhs", "rhs"))
    stop("Can only add rhs or lhs terms to a formula")
  
  if (!is.character(terms))
    stop("Expecting character vector of terms")
  
  components <- splitFormula(formula)
  
  if (type == "lhs")
    components[["lhs"]] <- union(components[["lhs"]], terms)
  else
    components[["rhs"]] <- union(components[["rhs"]], terms)
  
  return(makeFormula(lhs = components[["lhs"]], rhs = components[["rhs"]]))
}

getComponentsFromTerm <- function(term, excludeInteractions) {
  if (!is.character(term) || nchar(term) == 0)
    return(NULL)
  
  components <- trimws(unlist(strsplit(term, "+", fixed = TRUE)))
  
  if (excludeInteractions) {
    purgedComponents <- NULL
    for (component in components)
      if (!grepl(":", component, fixed = TRUE))
        purgedComponents <- c(purgedComponents, component)
      components <- purgedComponents
  }
  
  return(components)
}

makeFormula <- function(lhs, rhs, env = parent.frame(2)) {
  lhs <- paste(lhs, collapse = "+")
  rhs <- paste(rhs, collapse = "+")
  
  return(formula(paste(lhs, "~", rhs), env = env))
}

convertOptionNames <- function(options) {
  mapping <- list(dep               = "dependent", # formula, nullModel
                  fixed             = "fixedFactors",
                  random            = "randomFactors",
                  covariates        = "covariates",
                  model             = "modelTerms",
                  priorFixed        = "priorFixedEffects",
                  priorRandom       = "priorRandomEffects",
                  priorCovariates   = "priorCovariates",
                  effects           = "effects",
                  effectsType       = "effectsType",
                  postEst           = "posteriorEstimates",
                  ci                = "credibleInterval",
                  criTable          = "criTable",
                  bfOrder           = "bayesFactorOrder",
                  bfType            = "bayesFactorType",
                  groupPost         = "groupPosterior",
                  singleModel       = "singleModelTerms",
                  singleEst         = "singleModelEstimates",
                  singleCriTable    = "singleModelCriTable",
                  singlePostPlot    = "singleModelPosteriorPlot",
                  singleQqPlot      = "singleModelqqPlot",
                  singleRsqPlot     = "singleModelrsqPlot",
                  singleGroupPost   = "singleModelGroupPosterior",
                  postHocVars       = "postHocTestsVariables",
                  postHocNull       = "postHocTestsNullControl",
                  descr             = "descriptives",
                  descrVarOnYAxis   = "plotHorizontalAxis",
                  descrVarAsLines   = "plotSeparateLines",
                  descrVarAsPlots   = "plotSeparatePlots",
                  wantPlotCi        = "plotCredibleInterval",
                  plotCi            = "plotCredibleIntervalInterval",
                  postPlot          = "posteriorPlot",
                  qqPlot            = "qqPlot",
                  rsqPlot           = "rsqPlot",
                  fixedNumAcc       = "fixedNumAcc",
                  fixedMCMCSamples  = "fixedMCMCSamples",
                  sampleModeNumAcc  = "sampleModeNumAcc",
                  sampleModeMCMC    = "sampleModeMCMC")
  
  oldNames <- names(options)
  newNames <- oldNames
  for (i in seq_along(oldNames))
    if (oldNames[i] %in% names(mapping))
      newNames[i] <- mapping[[oldNames[i]]]
  
  names(options) <- newNames
  
  return(options)
}
```

</details>

### Generating Syntax Based on Selected Input Options in JASP
-    Utilize options R6 class, simply supply normal options json

### Displaying Syntax in JASP
There needs to be an area in JASP where the user can find the syntax that was generated by their option selection. Considering syntax is a description of the input of an analysis a natural place for this would be to be in the QML input panel. We can add an additional button on top of an analysis panel that lets users toggle between clickable options and the syntax. Alternatively we could create a new panel to the left of the options input panel.

### Running an Analysis in RStudio
To make it easy to perform an analysis in R it needs to be simple to install our R packages and run them. They should not need anything from JASP.

#### Package Eco-system
A number of packages need to be created with distinct sets of functionality. Doing so, will ensure people can check the namespace and only find a coherent set of functions (e.g., `descriptives()` and `reliability()` will be together, but not `hasErrors()`). Furthermore, this will ensure we can easily update separate components, without users having to reinstall everything when something unrelated to what they do (i.e., develop, or run analyses) changes.
- `jasp`: A package that bundles all the R analyses in one namespace. Installs all the required R analysis packages that are created by the JASP team. Exports only the analysis functions and the functions for the filter and column computation. The benefit of this approach is that users only need to know about a single package, only need to install packages once and it becomes clear from looking at the `jasp` namespace which analyses are available. External modules can be installed as separate R packages.
- `jaspAnalysis` (or `jaspCore`, `jaspBackbone`, ...): A package that contains all the building blocks for creating a JASP R analysis. This is basically a combination of jaspResults and the convenience functions such as those found in common.R and commonerrorcheck.R.
- `jaspGraphs`: A package that handles all our plotting needs.
- `jaspTools`: A package that aids an R analysis developer with the creation of their JASP R analysis. It exports functions related to the creation of an JASP-R package skeleton, the handling of translations, creation of a wrapper, etc.

#### Analysis (Environment)
To ensure analyses can be run from R, 
- The `jaspAnalysis` package needs to provide drop-in replacements for the cpp functions defined in `jasprcpp.cpp` (e.g., `encodeColNamesStrict`).
- The `jaspAnalysis` package needs to make column encoding available to ensure that when an analysis works in JASP it will also work in R.
- The `jaspAnalysis` package needs to make the `jaspResults` object assignable to a variable, in this way users can run multiple analyses.
- Each analysis must be able to correctly deal with receiving data directly through the `dataset`.

#### Result Structure
The output an RStudio user gets from an analysis must be a sensible data structure:
- The excessive nesting must be reduced to top level elements.
- Names must be short and to the point, instead of the long concatenations.
- Plots should go directly to the plotviewer.
- Tables need to be a common format like a regular data.frames or the like that allows users to easily use them for further analysis (there might be some trouble with casesAcrossColumns and column folding).
- There needs to be a good ASCII print of jaspHtml and jaspTables that closely mimics the output in JASP (there is some package that can do this too -- it also adds footnotes).

#### Analysis helpfiles
The user will need access to the help provided in JASP:
- `?jasp::banova` should return a common help index page of the input arguments (TODO see generating a wrapper).
- `info(jasp::banova(...args...))` could be used to return an enriched ASCII representation of the analysis. Each output element will have info added next to it; these info elements can be extracted from the `$addInfo`'s used in the analysis.

Problems:
-    Can analyses have multiple formulas?
-    Where to add formula and isNuisance in the options list? Model terms?
-    `jaspAnalysis` will not be an R package in JASP; how can we translate it?


